<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Margin与Padding的区别]]></title>
    <url>%2F2019%2F07%2F10%2FMargin%E4%B8%8EPadding%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Margin ：用来设置页面中一个元素所占空间的边缘到相邻元素之间的距离. Padding：用来设置元素内容到元素边界的距离。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA类与对象的生命周期问题]]></title>
    <url>%2F2019%2F07%2F10%2FJAVA%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[（未完待续） JVMjava虚拟机中有几个重要的内存区域。 方法区：存放已经加载的类信息、常量、静态变量以及方法代码的内存区。 常量池：是方法区的一部分，用来存放常量和类中的符号引用等信息。 堆区：存放类的实例化对象。 栈区：是后进先出的栈式结构，存放方法运行时产生的局部变量和方法出口等信息。调用一个方法时，栈区就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果在该方法中调用了其他方法，则继续在栈顶创建新的栈帧。 本地方法栈：与栈区类似，本地方法栈用于执行本地方法（系统提供的底层方法），栈区用于执行java程序。 PC寄存器：可以看成是当前线程所执行的字节码的行号指示器。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
        <tag>类</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本知识-校招笔面试常见问题]]></title>
    <url>%2F2019%2F07%2F10%2FJava%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86-%E6%A0%A1%E6%8B%9B%E7%AC%94%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本数据类型有八个基本储存单位：位-bit。 基本数据类型分二进制（boolean）类型数值类型，数值类型又分整数类和浮点数类。 byte 8bit char 16bit / 2B short 16bit int 32bit/4B long 64bit/8B float 32bit/4B double 64bit/8B boolean boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 并不直接支持 boolean 数组，而是使用 byte 数组来表示 int 数组。 表达式类型的自动提升当一个java算术表达式中包含多个基本类型的值时（没有定义的常数会被认为是int类型），整个算术表达式的数据类型将发生自动提升。Java定义如下的自动提升规则： 所有byte型、short型和char型将被提升到int型。 允许提升的顺序如下所示： byte可以升为short，short和char可以升为int，int升long，long升float，float升double。 符合上述顺序时，可以跨级提升，例如int可以直接升为double，但是逆向是不允许的。 例题代码列表1： 123short s1 = 1;s1 = s1 + 1; 代码列表2： 12short s1 = 1;s1 += 1; 请问以上两段代码是否可以运行，如果不能，错在哪里？第一段不能运行，因为第二行的1被编译器认为是int类型， int类型不能赋值给short类型的s1；第二段可以，java会对+=做特殊处理。 包装类型上次讲过基本数据类型和包装类的装箱拆箱问题。 char的包装类型Character;int的包装类型Integer；float的包装类型Float；double的包装类型Double 包装类型与基本数据类型的区别 包装类可以存null值，但是基本数据类型不可以； 基本数据类型是值传递，包装类型是引用传递，后面细讲； 变量值存储在栈里，对象存储在堆里，后面细讲； JVMjava 虚拟机的简称，有几个比较重要的知识点：JVM内存结构、垃圾回收（GC）算法 JVM内存结构内存结构需要重点掌握，JVM内存结构主要有三块：堆内存、方法区和栈。 堆内存 堆内存是JVM中最大的一块，由年轻代和老年代组成，年轻代还可以细分，暂时无需掌握； 该区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存； java堆被所有线程共享，在虚拟机启动时创建； java堆是垃圾回收的主要区域，所以也被成为GC堆； 可能抛出的异常是OutOfMemoryError(OOM)，也就堆溢出，这种异常比较常见，需要判断是内存溢出还是内存泄漏。内存溢出是指程序在申请内存时，没有足够的内存供其使用，例如申请了一个int类型，但是给它赋值了long才能存下的数，就会出现内存溢出。内存泄漏是指程序申请内存后，无法释放已申请的内存空间，JVM有垃圾回收，但是一些情况下也需要手动回收，将无用的对象手动清除。 方法区 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的； 方法区有时候被称为持久代，因为该区域的垃圾回收机制较为苛刻。 栈 栈分为本地方法栈和java虚拟机栈，本地方法栈是为使用到的本地方法服务的，java虚拟机栈则是为java方法服务的，用的较多。 java虚拟机栈是线程私有的，其生命周期与线程相同。 java虚拟机栈描述的是java方法执行的内存模型，线程中每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息，方法被调用直到执行完成的过程对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 常见异常对内存结构清晰的认识同样可以帮助理解不同OutOfMemoryErrors： 1Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space 原因：对象不能被分配到堆内存中 1Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space 原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库； 1Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit 原因：创建的数组大于堆内存的空间 1Exception in thread “main”: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space? 原因：分配本地分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。 1Exception in thread “main”: java.lang.OutOfMemoryError: &lt;reason&gt; &lt;stack trace&gt;（Native method） 原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现 程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 垃圾回收先了解这个概念。JVM GC会自动回收无用的内存空间， 类加载强引用、软引用、弱引用、虚引用 强引用 软引用 弱引用 虚引用 面向对象的三个基本特征java作为面向对象的编程语言，具有三个基本特征：封装、继承和多态。 封装封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是比较简单的特征，例如一台手机，我希望将它的内部结构如主板等隐藏，并且暴露一个交互接口屏幕，java中的封装也是类似的，可以将成员变量和具体实现隐藏，只预留一个可供使用的接口。 继承线程和进程进程进程是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位。 线程线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。 区别和联系 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源； 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 进程间通信 管道（pipe）； 信号量； 消息队列（queue）； 信号； 套接字（socket）。 线程间通信 使用全局变量； 使用消息（Message）实现通信； 线程同步 在需要同步的方法的 方法签名中加上 synchronized关键字； 使用synchronized关键字对需要进行同步的代码块进行同步； 使用特殊域变量(volatile)； synchronized和 volatile的区别 volatile不能保证操作原子性，synchronized可以。 网络基础七层协议OSI（Open System Interconnection）模型定义了七层结构： 1. 物理层有关传输介质的特性。 2.数据链路层定义了在单个链路上如何传输数据。 3. 网络层对端到端的包传输进行定义，IP协议属于这一层。 4.传输层是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能，TCP和UDP协议属于这一层。 5. 会话层它定义了如何开始、控制和结束一个会话。 6. 表示层这一层的主要功能是定义数据格式及加密。 7.应用层与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。HTTP、FTP、Telnet协议属于这一层。 TCP与UDP的区别 TCP是基于连接的，UDP是无连接的； TCP要求系统资源较多，UDP较少； TCP是面向数据流的；UDP是面向数据报的； TCP保证数据正确性，UDP可能丢包 ； TCP保证数据顺序，UDP不保证； TCP有流量控制和拥塞控制：TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制； TCP为什么是三次握手，不能是两次第一次握手：客户端像服务端请求建立连接，自身进入半连接状态，等待服务端确认连接； 第二次握手：服务端接受客户端的请求，向客户端返回确认包，进入半连接状态，等待客户端再次确认连接； 第三次握手：客户端回复确认包，两方进入连接状态。 如果缺少了第三次握手的过程，在客户端第一次提出连接申请后，不再需要建立连接或因故障离线，服务端接受了连接请求就进入了连接状态，但是客户端此时无法再与其建立连接，造成资源浪费。 在握手阶段常见SYN攻击，攻击者伪造大量虚假IP，向服务器发送连接请求，使得服务器进入半连接状态，并持续向虚假IP发送确认连接包，直到超时才能释放相关资源，伪造的SYN包占用队列，导致正常的SYN包被丢弃，造成网络拥塞。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>面试</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 基本操作]]></title>
    <url>%2F2019%2F07%2F10%2Fgit-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[##常用命令 输出commit信息：git log –pretty=format:”%h - %an, %ar : %s” 日常操作抓取fetch，获取代码更新。 拉取pull，拉取远端代码到本地。 推送push，将本地commit推送到远端仓库。 merge&amp;rebasegit rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，应用场景如下图 merge在feature分支进行开发，master上有新的提交时，你需要将master上的新提交同步到你的feature分支上。在merge之后，分支会变成如下图所示 可以使用如下命令 1git merge -no-ff git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。 git merge 则不会显示 feature，只保留单条分支记录。 如下图所示 merge会创建一个新的commit，如果有冲突，则需要先修改冲突。 操作流程检出到master分支：git checkout master 先拉取代码：git pull 然后检出到feature分支：git checkout master 执行merge提交：git merge master --no-ff 冲突合并操作-遴选 场景：有两个分支A和B，把分支B上的某一条commit合并到A上 操作步骤： 切换到分支A； 选中分支B中需要合并到A上的那条commit； 右键，遴选(cherry-pick)。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 绘制流程]]></title>
    <url>%2F2019%2F07%2F10%2FView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[View 绘制机制1. View 树的绘图流程当 Activity 接收到焦点的时候，它会被请求绘制布局,该请求由 Android framework 处理.绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在ViewRoot.java类的performTraversals()函数展开，该函数所做 的工作可简单概况为是否需要重新计算视图大小(measure)、是否需要重新安置视图的位置(layout)、以及是否需要重绘(draw)，流程图如下： View 绘制流程函数调用链图片来自 https://plus.google.com/+ArpitMathur/posts/cT1EuBbxEgN需要说明的是，用户主动调用 request，只会出发 measure 和 layout 过程，而不会执行 draw 过程 2. 概念measure 和 layout 从整体上来看 Measure 和 Layout 两个步骤的执行： 树的遍历是有序的，由父视图到子视图，每一个 ViewGroup 负责测绘它所有的子视图，而最底层的 View 会负责测绘自身。 具体分析measure 过程由measure(int, int)方法发起，从上到下有序的测量 View，在 measure 过程的最后，每个视图存储了自己的尺寸大小和测量规格。 layout 过程由layout(int, int, int, int)方法发起，也是自上而下进行遍历。在该过程中，每个父视图会根据 measure 过程得到的尺寸来摆放自己的子视图。 measure 过程会为一个 View 及所有子节点的 mMeasuredWidth 和 mMeasuredHeight 变量赋值，该值可以通过 getMeasuredWidth()和getMeasuredHeight()方法获得。而且这两个值必须在父视图约束范围之内，这样才可以保证所有的父视图都接收所有子视图的测量。如果子视图对于 Measure 得到的大小不满意的时候，父视图会介入并设置测量规则进行第二次 measure。比如，父视图可以先根据未给定的 dimension 去测量每一个子视图，如果最终子视图的未约束尺寸太大或者太小的时候，父视图就会使用一个确切的大小再次对子视图进行 measure。 measure 过程传递尺寸的两个类 ViewGroup.LayoutParams （View 自身的布局参数） MeasureSpecs 类（父视图对子视图的测量要求） ViewGroup.LayoutParams这个类我们很常见，就是用来指定视图的高度和宽度等参数。对于每个视图的 height 和 width，你有以下选择： 具体值 MATCH_PARENT 表示子视图希望和父视图一样大(不包含 padding 值) WRAP_CONTENT 表示视图为正好能包裹其内容大小(包含 padding 值) ViewGroup 的子类有其对应的 ViewGroup.LayoutParams 的子类。比如 RelativeLayout 拥有的 ViewGroup.LayoutParams 的子类 RelativeLayoutParams。有时我们需要使用 view.getLayoutParams() 方法获取一个视图 LayoutParams，然后进行强转，但由于不知道其具体类型，可能会导致强转错误。其实该方法得到的就是其所在父视图类型的 LayoutParams，比如 View 的父控件为 RelativeLayout，那么得到的 LayoutParams 类型就为 RelativeLayoutParams。 MeasureSpecs测量规格，包含测量要求和尺寸的信息，有三种模式: UNSPECIFIED父视图不对子视图有任何约束，它可以达到所期望的任意尺寸。比如 ListView、ScrollView，一般自定义 View 中用不到， EXACTLY父视图为子视图指定一个确切的尺寸，而且无论子视图期望多大，它都必须在该指定大小的边界内，对应的属性为 match_parent 或具体值，比如 100dp，父控件可以通过MeasureSpec.getSize(measureSpec)直接得到子控件的尺寸。 AT_MOST父视图为子视图指定一个最大尺寸。子视图必须确保它自己所有子视图可以适应在该尺寸范围内，对应的属性为 wrap_content，这种模式下，父控件无法确定子 View 的尺寸，只能由子控件自己根据需求去计算自己的尺寸，这种模式就是我们自定义视图需要实现测量逻辑的情况。 3. measure 核心方法 measure(int widthMeasureSpec, int heightMeasureSpec)该方法定义在View.java类中，为 final 类型，不可被复写，但 measure 调用链最终会回调 View/ViewGroup 对象的 onMeasure()方法，因此自定义视图时，只需要复写 onMeasure() 方法即可。 onMeasure(int widthMeasureSpec, int heightMeasureSpec)该方法就是我们自定义视图中实现测量逻辑的方法，该方法的参数是父视图对子视图的 width 和 height 的测量要求。在我们自身的自定义视图中，要做的就是根据该 widthMeasureSpec 和 heightMeasureSpec 计算视图的 width 和 height，不同的模式处理方式不同。 setMeasuredDimension()测量阶段终极方法，在 onMeasure(int widthMeasureSpec, int heightMeasureSpec) 方法中调用，将计算得到的尺寸，传递给该方法，测量阶段即结束。该方法也是必须要调用的方法，否则会报异常。在我们在自定义视图的时候，不需要关心系统复杂的 Measure 过程的，只需调用setMeasuredDimension()设置根据 MeasureSpec 计算得到的尺寸即可，你可以参考 [ViewPagerIndicator](https://a.codekk.com/detail/Android/lightSky/ViewPagerindicator 源码解析) 的 onMeasure 方法。 下面我们取 ViewGroup 的 measureChildren（int widthMeasureSpec, int heightMeasureSpec) 方法对复合 View 的 Measure 流程做一个分析： MeasureChild 的方法调用流程图： 源码分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /** * 请求所有子 View 去 measure 自己，要考虑的部分有对子 View 的测绘要求 MeasureSpec 以及其自身的 padding * 这里跳过所有为 GONE 状态的子 View，最繁重的工作是在 getChildMeasureSpec 方法中处理的 * * @param widthMeasureSpec 对该 View 的 width 测绘要求 * @param heightMeasureSpec 对该 View 的 height 测绘要求 */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams();//获取 Child 的 LayoutParams final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,// 获取 ChildView 的 widthMeasureSpec mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,// 获取 ChildView 的 heightMeasureSpec mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125;/** * 该方法是 measureChildren 中最繁重的部分，为每一个 ChildView 计算出自己的 MeasureSpec。 * 目标是将 ChildView 的 MeasureSpec 和 LayoutParams 结合起来去得到一个最合适的结果。 * * @param spec 对该 View 的测绘要求 * @param padding 当前 View 在当前唯独上的 paddingand，也有可能含有 margins * * @param childDimension 在当前维度上（height 或 width）的具体指 * @return 子视图的 MeasureSpec */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; ......... // 根据获取到的子视图的测量要求和大小创建子视图的 MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; /** * * 用于获取 View 最终的大小，父视图提供了宽、高的约束信息 * 一个 View 的真正的测量工作是在 onMeasure(int, int) 中，由该方法调用。 * 因此，只有 onMeasure(int, int) 可以而且必须被子类复写 * * @param widthMeasureSpec 在水平方向上，父视图指定的的 Measure 要求 * @param heightMeasureSpec 在竖直方向上，控件上父视图指定的 Measure 要求 * */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 4. layout 相关概念及核心方法首先要明确的是，子视图的具体位置都是相对于父视图而言的。View 的 onLayout 方法为空实现，而 ViewGroup 的 onLayout 为 abstract 的，因此，如果自定义的 View 要继承 ViewGroup 时，必须实现 onLayout 函数。 在 layout 过程中，子视图会调用getMeasuredWidth()和getMeasuredHeight()方法获取到 measure 过程得到的 mMeasuredWidth 和 mMeasuredHeight，作为自己的 width 和 height。然后调用每一个子视图的layout(l, t, r, b)函数，来确定每个子视图在父视图中的位置。 ** LinearLayout 的 onLayout 源码分析** 123456789101112131415161718192021222324252627282930313233343536373839404142434445 @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; /** * 遍历所有的子 View，为其设置相对父视图的坐标 */ void layoutVertical(int left, int top, int right, int bottom) &#123;for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123;//不需要立即展示的 View 设置为 GONE 可加快绘制 final int childWidth = child.getMeasuredWidth();//measure 过程确定的 Width final int childHeight = child.getMeasuredHeight();//measure 过程确定的 height ...确定 childLeft、childTop 的值 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); &#125; &#125;&#125; private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; View.java public void layout(int l, int t, int r, int b) &#123; ... setFrame(l, t, r, b) &#125; /** * 为该子 View 设置相对其父视图上的坐标 */ protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... &#125; 5. 绘制流程相关概念及核心方法先来看下与 draw 过程相关的函数： View.draw(Canvas canvas)： 由于 ViewGroup 并没有复写此方法，因此，所有的视图最终都是调用 View 的 draw 方法进行绘制的。在自定义的视图中，也不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制，如果自定义的视图确实要复写该方法，那么请先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制。 View.onDraw()：View 的onDraw（Canvas）默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。 dispatchDraw() 发起对子视图的绘制。View 中默认是空实现，ViewGroup 复写了dispatchDraw()来对其子视图进行绘制。该方法我们不用去管，自定义的 ViewGroup 不应该对dispatchDraw()进行复写。 绘制流程图 - View.draw(Canvas) 源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. * * 根据给定的 Canvas 自动渲染 View（包括其所有子 View）。在调用该方法之前必须要完成 layout。当你自定义 view 的时候， * 应该去是实现 onDraw(Canvas) 方法，而不是 draw(canvas) 方法。如果你确实需要复写该方法，请记得先调用父类的方法。 */ public void draw(Canvas canvas) &#123; / * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background if need * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children (dispatchDraw) * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we&apos;re done... return; &#125; // Step 2, save the canvas&apos; layers ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 由上面的处理过程，我们也可以得出一些优化的小技巧：当不需要绘制 Layer 的时候第二步和第五步会跳过。因此在绘制的时候，能省的 layer 尽可省，可以提高绘制效率 ViewGroup.dispatchDraw() 源码分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455dispatchDraw(Canvas canvas)&#123;... if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123;//处理 ChildView 的动画 final boolean buildCache = !isHardwareAccelerated(); for (int i = 0; i &lt; childrenCount; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;//只绘制 Visible 状态的布局，因此可以通过延时加载来提高效率 final LayoutParams params = child.getLayoutParams(); attachLayoutAnimationParameters(child, params, i, childrenCount);// 添加布局变化的动画 bindLayoutAnimation(child);//为 Child 绑定动画 if (cache) &#123; child.setDrawingCacheEnabled(true); if (buildCache) &#123; child.buildDrawingCache(true); &#125; &#125; &#125; &#125; final LayoutAnimationController controller = mLayoutAnimationController; if (controller.willOverlap()) &#123; mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE; &#125; controller.start();// 启动 View 的动画&#125; // 绘制 ChildView for (int i = 0; i &lt; childrenCount; i++) &#123; int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125;...&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125;/** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * This draw() method is an implementation detail and is not intended to be overridden or * to be called from anywhere else other than ViewGroup.drawChild(). */ boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ... &#125; drawChild(canvas, this, drawingTime)直接调用了 View 的child.draw(canvas, this,drawingTime)方法，文档中也说明了，除了被ViewGroup.drawChild()方法外，你不应该在其它任何地方去复写或调用该方法，它属于 ViewGroup。而View.draw(Canvas)方法是我们自定义控件中可以复写的方法，具体可以参考上述对view.draw(Canvas)的说明。从参数中可以看到，child.draw(canvas, this, drawingTime) 肯定是处理了和父视图相关的逻辑，但 View 的最终绘制，还是 View.draw(Canvas)方法。 invalidate()请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些调用了invalidate()方法的 View。 requestLayout()当布局变化的时候，比如方向变化，尺寸的变化，会调用该方法，在自定义的视图中，如果某些情况下希望重新测量尺寸大小，应该手动去调用该方法，它会触发measure()和layout()过程，但不会进行 draw。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式-线程安全]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。 懒汉式，线程不安全当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。 懒汉式，线程安全为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。 123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance;&#125; 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。 双重检验锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 12345678910public static Singleton getSingleton() &#123; if (instance == null) &#123; //Single Checked synchronized (Singleton.class) &#123; if (instance == null) &#123; //Double Checked instance = new Singleton(); &#125; &#125; &#125; return instance ;&#125; 这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 我们只需要将 instance 变量声明成 volatile 就可以了。 12345678910111213141516public class Singleton &#123; private volatile static Singleton instance; //声明成 volatile private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。 饿汉式 static final field这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 12345678910public class Singleton&#123; //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 静态内部类 static nested class我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 枚举 Enum用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。 123public enum EasySingleton&#123; INSTANCE;&#125; 我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。 总结一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。 就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「代码整洁之道」读书笔记]]></title>
    <url>%2F2019%2F07%2F10%2F%E3%80%8C%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[命名 避免误导，避免使用accountList来指一组账号，除非它真的是List类型 使用读得出来的名称，避免使用不便于阅读或理解的缩写词 名称长短应与其作用域大小相对应，长名称胜过短名称，便于检索 避免使用无意义的前后缀 明确是王道 函数 函数应该短小，20行封顶最佳 函数应该只做一件事，只做同一抽象层上的步骤 函数要么做一件事，要么回答一个问题，不要同时做这两个事 参数应该尽量少，参数太多时应该把几个参数抽象成对象 消除时序性耦合，避免产生副作用 避免使用输出参数，可以修改所属对象的状态 把try和catch代码块抽离形成函数，避免把正常流程和错误处理放在一起 错误处理就是一件事，处理错误的函数不该做其他事，try/catch代码块前后不该有其他内容 消除重复（怎么做？） 注释 注释不能美化糟糕的代码 对意图的注释，对特殊代码的注释，有助于理解 避免喃喃自语，避免循轨式注释和日志式注释 及时删除注释掉的代码 对象和数据结构 使用数据结构（过程式代码）便于在不改动既有数据结构前提下添加新函数，使用面向对象代码便于在既有函数的前提下添加新类 避免连串调用 数据传送对象（DTO） 错误处理 使用异常，不要使用返回错误码的方式 不要返回和传递null 边界 将第三方API包装起来，以此来把第三方API的边界接口与程序的其他部分隔离开来 类 类应该短小 类应该只有一个权责——只有一条加以修改的理由 味道 G2，函数或类应该实现其他程序员有理由期待的行为 G7，基类不应该依赖于派生类 G18，静态方法应该不在任何特定对象上操作，从参数中获得全部数据，还要确保没机会让它有多态行为 G23，用多态替代if/else或switch/case G25，用命名常量代替数字或字符串 G28，应该将布尔逻辑抽离，形成单独的函数 G31，如果有时序耦合，应该排列函数参数，强调他们被调用的次次序 J3，使用枚举类代替常量]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
</search>
